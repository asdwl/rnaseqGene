---
title: "RNA-seq 工作流程: 基因水平的探索性分析和差异表达分析"
author:
- name: Michael I. Love
  affiliation: 
  - Department of Biostatistics, UNC-Chapel Hill, Chapel Hill, NC, US
  - Department of Genetics, UNC-Chapel Hill, Chapel Hill, NC, US
- name: Simon Anders
  affiliation: Zentrum für Molekulare Biologie der Universität Heidelberg, Heidelberg, Germany
- name: Vladislav Kim
  affiliation: &EMBL European Molecular Biology Laboratory (EMBL), Heidelberg, Germany
- name: Wolfgang Huber
  affiliation: *EMBL
date: 11 April, 2018
output: BiocStyle::html_document
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{RNA-seq workflow at the gene level}
  %\VignetteEngine{knitr::rmarkdown}
abstract: |
  这里我们使用Bioconductor包执行一个端到端的基因水平RNA-seq差异表达分析工作流程。 我们会从FASTQ文件开始， 展示如何与参考基因组比对，如何准备每个样本中每个基因的RNA-seq片段的计数矩阵。 我们会进行探索性数据分析（EDA）以完成质量评估，并且为了探索样本之间的关系，执行差异基因表达分析，最后对结果进行可视化。

---

<!-- to compile this: rmarkdown::render("rnaseqGene.Rmd") -->

<!--
     # a list of all required libraries:
     reqlibs = sub(".*library\\(\"(.*?)\"\\).*","\\1",grep("library\\(",readLines("rnaseqGene.Rmd"),value=TRUE))
     find.package(reqlibs)
-->


```{r style, echo=FALSE, message=FALSE, warning=FALSE, results="asis"}
library("BiocStyle")
library("knitr")
library("rmarkdown")
opts_chunk$set(message = FALSE, error = FALSE, warning = FALSE,
               cache = FALSE, fig.width = 5, fig.height = 5)
```

**R version**: `r R.version.string`

**Bioconductor version**: `r BiocManager::version()`

**Package**: `r packageVersion("rnaseqGene")`


# 介绍

Bioconductor有许多支持高通量序列数据分析的包, 包括RNA sequencing (RNA-seq)。
我们在这个工作流中使用的包包括由Bioconductor核心团队维护的核心包，其是用来导入
和处理原始的序列数据并加载基因注释的。我们也会用其他的包进行统计分析和数据可视化。
通过每6个月一次的发布计划，bioconductor项目可以确保所有发布的包在整体上运行流畅。
（这也是“conductor”一词的隐喻）。本工作流中使用的包用
*library* 函数加载，并可以通过以下链接安装
[Bioconductor 包安装说明](http://bioconductor.org/install/#install-bioconductor-packages)。

此工作流程的已发布（但基本相似）版本，包含有审阅报告和评论见
[F1000Research](http://f1000research.com/articles/4-1070)。

如果您对此工作流程或Bioconductor软件有任何疑问，请将这些发布到
[Bioconductor support site](https://support.bioconductor.org/)。
如果你的问题涉及特定的包，你可以在发布中加上包的名字作为标签, 如果是关于工作流的一般性问题,
在发布中加上标签`rnaseqgene`。参考
[发布指南](http://www.bioconductor.org/help/support/posting-guide/)
以使你在网站中发布的问题合乎规范。

## 实验数据

本工作流程使用数据存储在 `r Biocexptpkg("airway")` 包中，这是一个用地塞米松
（一种合成的有抗炎作用的糖皮质激素）处理呼吸道平滑肌细胞的RNA-seq实验
[@Himes2014RNASeq]。糖皮质激素被用于，诸如，减少哮喘病人的呼吸道炎症。实验中，
四个原代的人呼吸道平滑肌细胞系用1μmol地塞米松处理18小时，每个细胞系都有一个处理的样本
和未处理的对照样本。关于实验的更多内容参见
[PubMed entry 24926665](http://www.ncbi.nlm.nih.gov/pubmed/24926665)，
实验的原始数据参见
[GEO entry GSE52778](http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE52778)。

<a id="count"></a>

# 准备计数矩阵

那些基于计数的统计方法，比如
`r Biocpkg("DESeq2")` [@Love2014Moderated],
`r Biocpkg("edgeR")` [@Robinson2009EdgeR],
`r Biocpkg("limma")` with the voom method [@Law2014Voom],
`r Biocpkg("DSS")` [@Wu2013New], 
`r Biocpkg("EBSeq")` [@Leng2013EBSeq] and
`r Biocpkg("baySeq")` [@Hardcastle2010BaySeq],
期望的输入数据是从RNA-seq等高通量测序实验中获得的，一个整数格式的矩阵。
矩阵中 *i* 行和 *j* 列的值表示样本 *j* 中的基因 *i*有多少reads（对于双端测序来说，
是fragments）。类似的，对于其他类型的实验， 矩阵的行可以对应于诸如：结合区域（ChIP-Seq），
细菌种类（宏基因组数据集）或蛋白序列（定量质谱）。

矩阵中的值应该是测序的reads/fragments计数，这一点对于维持 *DESeq2* 统计模型的正常
运行十分重要，因为只有计数值才能正确的评估测量的精确度。特别要说明的是不要使用对测序深度
或文库大小进行了预标准化的计数值，因为统计模型使用未标准化的计数时效果最好，并且 *DESeq2* 
的内部设计中已经考虑了文库大小的差异。

## 推荐: 转录本丰度和 *tximport* 流程

在演示如何比对并计数RNA-seq片段之前，我们提及一种更新更快的用于转录本丰度定量的可选的
流程，诸如：
[Salmon](https://combine-lab.github.io/salmon/) [@Patro2017Salmon]，
[Sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/) [@Patro2014Sailfish]，
[kallisto](https://pachterlab.github.io/kallisto/) [@Bray2016Near]，或者
[RSEM](http://deweylab.github.io/RSEM/) [@Li2011RSEM]，
它们可以在没有比对reads的情况下估算转录丰度，接着用 `r Biocpkg("tximport")` 包来组装
估算的计数并为Bioconductor差异基因表达包提供使用的矩阵。 

这是一个关于如何使用 *Salmon* 软件来定量转录本丰度的教程
[（点击此处）](https://combine-lab.github.io/salmon/getting_started/).
我们建议使用 `--gcBias` 
[flag](http://salmon.readthedocs.io/en/latest/salmon.html#gcbias)
为RNA-seq数据中常见的系统偏差估算一个校正因子 
[@Love2016Modeling; @Patro2017Salmon]，
除非你确信你的数据没有这样的偏差。
按照Salmon教程，你可以根据
[tximport vignette](https://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html)，
中的步骤，来学习如何建立一个 *DESeqDataSet*。这是我们目前推荐用户使用的流程，
但是下面我们仍然会讲解关于基因组reads比对和从BAM文件中建立计数矩阵的步骤。

协同使用转录本丰度量化软件和 *tximport* 来产生基因水平的计数矩阵和标准化补偿的优势是：
这种方法校正了不同样本间基因长度的潜在改变 (如差异异构体造成的改变）
[@Trapnell2013Differential]；与基于比对的方法相比，这些方法中的其中一些
速度更快，所需的内存和磁盘使用量更少，并且可以避免丢弃那些可以与同源序列的多个基因比对上
的片段[@Robert2015Errors]。注意，转录本丰度量化软件不产生存储read aligments的
大文件，而是产生存储着估算丰度，计数值以及每个转录本有效长度的小文件。更多细节请参考相关
的手册[@Soneson2015Differential]，以及概括了软件细节的 
`r Biocpkg("tximport")` 包。使用了转录本量化软件和 *tximport* 后回到此工作流的
切入点在 [section on exploratory data analysis](#eda) 下面。

## 将reads比对到参考基因组上

RNA-seq实验的计算分析从FASTQ文件开始，该文件含有每个read的核苷酸序列和每个位点的质量分数。
这些reads首先与参考基因组或转录组进行比对，或者像上面描述的那样，在未比对的情况下估算
转录本的丰度和计数值。不管哪种情况，知道这个测序实验是双端还是单端的很重要，因为比对软件会
要求用户为双端实验指定两个FASTQ文件。此比对步骤的通常会输出一个
[SAM/BAM](http://samtools.github.io/hts-specs)格式的文件。

许多的软件都能进行和参考基因组的read比对，我们建议你查阅一些国际上的相关文献，这些文献讨论了
这些软件在精度，拼接点处的比对灵敏度，速度，内存要求，实用性以及许多其他特点上的优缺点，
我们在这里使用
[STAR read aligner](https://code.google.com/p/rna-star/) [@Dobin2013STAR]
来将我们当前实验的reads和 Ensembl
release 75 [@Flicek2014Ensembl]人类参考及基因组进行比对。
在下面的示例代码中，假设当前目录中有一个名为`files`的文件，文件的每一行都包含每个实验的标识符，
所有的FASTQ文件在二级目录`fastq`中。如果你已经从Sequence Read Archive下载了FASTQ文件，
那么标识符就是SRA run IDs，比如`SRR1039520`。双端实验的每个ID有两个文件，`fastq/SRR1039520_1.fastq1`和`fastq/SRR1039520_2.fastq`，分别表示双端片段的第一个
和第二个read。如果你执行的是单端实验，那么每个ID只有一个文件。我们建立一个二级目录`aligned`，
STAR在这里输出它的比对文件。

```
for f in `cat files`; do STAR --genomeDir ../STAR/ENSEMBL.homo_sapiens.release-75 \
--readFilesIn fastq/$f\_1.fastq fastq/$f\_2.fastq \
--runThreadN 12 --outFileNamePrefix aligned/$f.; done
```

[SAMtools](http://www.htslib.org/doc/samtools.html) [@Li2009Sequence]
用于产生BAM文件。`-@` 标记用于分配额外的线程。

```
for f in `cat files`; do samtools view -bS aligned/$f.Aligned.out.sam \
-o aligned/$f.bam; done
```
BAM文件可以用于生成计数矩阵，这会在下面的章节中进行描述。

## 定位比对文件

除了后面要用的计数矩阵，`r Biocexptpkg("airway")` 包还包含8个文件，这是实验中全部数目
的reads的一个小子集，选择的是与1号染色体的一个小区域比对的reads。出于演示的目的，我们
选择了reads的一个子集，因为完整的比对文件太大了（大约几个GB），而且计算每个样本的
fragments需要10-30分钟。我们会使用这些文件来演示如何从BAM文件中建立一个计数矩阵。之后，
我们会加载完整的包含全部样本和全部数据的计数矩阵，该矩阵在 `r Biocexptpkg("airway")` 
包中同样有提供，后续的分析会使用完整的矩阵。

加载有示例数据的数据包：

```{r loadairway}
library("airway")
```

R函数 *system.file* 用于查找包中的文件在你的计算机中上的安装位置。这里我们要求提供
`extdata`目录的完整路径，这个目录是R包用来存储外部数据的，是 `r Biocexptpkg("airway")` 
包的一部分。

```{r dir}
indir <- system.file("extdata", package="airway", mustWork=TRUE)
```

在这个目录中，我们找到了8个BAM文件(以及其他的一些文件):

```{r list.files}
list.files(indir)
```

通常，我们会有一个将样本和相应的FASTQ、BAM文件关联起来的详细信息的表格，在你自己的实验中，
你可以用文本编辑器或电子表格软件如Excel建立这样的逗号分隔符文件（CSV）。

我们用 *read.csv* 加载这个CSV文件：

```{r sampleTable}
csvfile <- file.path(indir, "sample_table.csv")
sampleTable <- read.csv(csvfile, row.names = 1)
sampleTable
```

完成reads比对后，有许多的工具可以用于计算每个样本中能与参考基因组比对上的reads/fragments的
数目。这些工具需要输入以下文件：SAM/BAM文件和一个指定基因组特征的文件，比如一个指定基因模型的GFF3
或GTF文件。

## *DESeq2* 导入函数

下列工具可以被用于生成计数矩阵：
*summarizeOverlaps* [@Lawrence2013Software],
*featureCounts* [@Liao2014FeatureCounts],
*tximport* [@Soneson2015Differential],
*htseq-count* [@Anders2015HTSeqa].

function            | package                                              | framework      | output                 | *DESeq2* input function
--------------------|------------------------------------------------------|----------------|------------------------|-------------------------
*summarizeOverlaps* | `r Biocpkg("GenomicAlignments")`                     | R/Bioconductor | *SummarizedExperiment* | *DESeqDataSet*
*featureCounts*     | `r Biocpkg("Rsubread")`                              | R/Bioconductor | matrix                 | *DESeqDataSetFromMatrix*
*tximport*          | `r Biocpkg("tximport")`                              | R/Bioconductor | list of matrices       | *DESeqDataSetFromTximport*
*htseq-count*       | [HTSeq](http://www-huber.embl.de/users/anders/HTSeq) | Python         | files                  | *DESeqDataSetFromHTSeq* 

这里我们用 *summarizeOverlaps* 来处理。
使用样本表格中的 `Run` 列，我们给将在其上执行计数操作的文件的建立一个完整路径：

```{r filenames}
filenames <- file.path(indir, paste0(sampleTable$Run, "_subset.bam"))
file.exists(filenames)
```

`r Biocpkg("Rsamtools")` 包给BAM文件提供了一个R接口，其中的 *BamFileList* 函数指定应用于
这里的文件。这里我们也指出了关于如何处理BAM文件的细节，比如一次只能处理200万的reads，键入 
`?BamFileList` 可以获得更多信息。

```{r Rsamtools}
library("Rsamtools")
bamfiles <- BamFileList(filenames, yieldSize=2000000)
```

**注意：** 确保你在注释中使用的基因组的染色体名称与用于read比对参考的染色体名称是一致的。
否则，脚本会由于名称错配而无法计算出任何符合特征的reads。例如，一个常见的错误是，比对文件中的
染色体名称是 `1`，而基因注释的染色体名称是 `chr1`，或者正好相反。解决方法见
 `r Biocpkg("GenomeInfoDb")` 包中的 *seqlevelsStyle* 函数。
我们可以像这样检查比对文件中的染色体名称（这里称为 "seqnames"）：

```{r seqinfo}
seqinfo(bamfiles[1])
```

## 定义基因模型

接下来，需要读入一个计数reads/fragments的基因模型。我们使用 `r Biocpkg("GenomicFeatures")` 
包中的 *makeTxDbFromGFF* 函数从Ensembl的一个
[GTF文件](http://www.ensembl.org/info/website/upload/gff.html) [@Flicek2014Ensembl]
中读入基因模型。GTF文件可以从
[Ensembl的FTP站点](http://www.ensembl.org/info/data/ftp/) 或者其他的基因模型仓库中下载。
*TxDb* 是一个数据库，可以用来生成各种以距离为基础的对象，比如外显子，转录本、基因。
我们想要制作一个按基因分组的外显子列表，用于计算reads/fragments。

也有其他构建 *TxDb* 的方法。
对于从 UCSC Genome Browser [@Kent2002Human]追踪到的 *known genes* ，您可以使用预先建立的
转录本数据库：`r Biocannopkg("TxDb.Hsapiens.UCSC.hg19.knownGene")`。
如果注释文件可以从 `r Biocpkg("AnnotationHub")` 获取（像Ensembl基因一样），
那么可以用 *makeTxDbFromGRanges* 函数导入一个预选扫描好的GFT文件。

这里我们演示从GFT文件处加载：

```{r genfeat}
library("GenomicFeatures")
```

我们使用一个长度为0的字符矢量来说明没有一个序列（染色体）是环状的。

```{r txdb}
gtffile <- file.path(indir,"Homo_sapiens.GRCh37.75_subset.gtf")
txdb <- makeTxDbFromGFF(gtffile, format = "gtf", circ_seqs = character())
txdb
```

下面这行生成了一个按基因[@Lawrence2013Software]分组的所有外显子的 *GRangesList* 。
列表中的每一个元素是一个基因的外显子的 *GRanges* 对象。

```{r}
ebg <- exonsBy(txdb, by="gene")
ebg
```

## Read计数步骤

经过这些准备工作，实际的计算是很容易的。 `r Biocpkg("GenomicAlignments")`包中的
*summarizeOverlaps* 函数会执行计算操作。这会产生一个 *SummarizedExperiment* 对象，
其中包含此实验的各种信息，并且下面会描述出更多的细节。

**注意：** 如果是想用多核执行的计算，你可以在执行计算之前使用
`r Biocpkg("BiocParallel")` 包中的 *register* 和 *MulticoreParam* 或 *SnowParam* 
函数。预计对于有3000万条比对reads的人RNA-seq文件， `summarizeOverlaps` 的调用将会耗费至少
30分钟每文件。把文件发送给不同的核心，计算过程会得到加速。

```{r}
library("GenomicAlignments")
library("BiocParallel")
```

这里我们指定使用单核，而不是多核。我们也可以跳过这一行，那么计数过程将会串联执行。

```{r}
register(SerialParam())
```

下面的操作生成了带有计数值的 *SummarizedExperiment* 对象：

```{r}
se <- summarizeOverlaps(features=ebg, reads=bamfiles,
                        mode="Union",
                        singleEnd=FALSE,
                        ignore.strand=TRUE,
                        fragments=TRUE )
```

我们在 `features` 和 `reads` 之外还指定了许多的参数。参数 `mode` 表示何种
read overlaps将会被计数。 全部的modes参见`r Biocpkg("GenomicAlignments")` 包
的 *Counting reads with summarizeOverlaps* 使用指南的图1。
注意fragments在每个基因中只会被计数一次，即使它们重叠在一个基因的多个外显子中。
将 `singleEnd` 设置为 `FALSE` 表示实验产生双端的reads，因此我们在一个基因的计算过程中
将一对reads只计算一次。
当 `singleEnd=FALSE` 时， `fragments` 参数可以被用于指定未配对的reads是否应该被计数。
（TRUE表示计数）。

为了生成正确的计数，要弄清楚RNA-seq实验是否是链特异性的。 这个实验不是链特异性的，所以我们
设置 `ignore.strand` 为 `TRUE`。
然而，有些链特异性的实验只能与基因的互补链进行reads比对。
用户必须检查其实验是否是链特异性的，如果是，reads应该同基因的正链还是负链比对。
对于各种计数/量化工具，我们指定以不同的方式对正向或反向链进行计数， 目前这个任务用 *htseq-count*，
*featureCounts*, 或者前面提到的转录本量化软件都能很容易的完成。
检查计数矩阵的（见下）的总列数很有必要，这可以确保其与基因比对的reads/fragments的预期数目一致。
此外，也可以用基因组可视化工具来直观地检查比对的结果。

## SummarizedExperiment查看

```{r sumexp, echo=FALSE}
par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0,100),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")
polygon(c(45,90,90,45),c(5,5,70,70),col="pink",border=NA)
polygon(c(45,90,90,45),c(68,68,70,70),col="pink3",border=NA)
text(67.5,40,"assay")
text(67.5,35,'e.g. "counts"')
polygon(c(10,40,40,10),c(5,5,70,70),col="skyblue",border=NA)
polygon(c(10,40,40,10),c(68,68,70,70),col="skyblue3",border=NA)
text(25,40,"rowRanges")
polygon(c(45,90,90,45),c(75,75,95,95),col="palegreen",border=NA)
polygon(c(45,47,47,45),c(75,75,95,95),col="palegreen3",border=NA)
text(67.5,85,"colData")
```

***SummarizedExperiment* 对象的构成.** `assay` （粉色块）
中包含了计数矩阵， `rowRanges` （蓝色快）中包含基因组范围信息， `colData` （绿色快）包含
样本信息。每个色块中高亮的行表示第一行（注意 `colData` 的第一行与`assay`的第一列是对齐的。）

*SummarizedExperiment* 容器图解如上，并在最新的Bioconductor文章中有讨论
[@Huber2015Orchestrating]。在我们的这个例子中，我们生成了一个名为"counts"的单矩阵，其包含
每个样本和每个基因的fragment计数值，其存储在 `assay`中。当然也可以在 `assays` 中存储多个矩阵。
这个对象中的 `rowRanges` 是 *GRangesList* ，用于计数。（计数矩阵中的每一行有一个外显子
 *GRanges* ）。使用同名的R函数访问 *summarzedexperiment* 的组件部分：`assay` 
（或者 `assays`），`rowRanges` and `colData`。

上面的示例代码实际上只计算了原始实验的fragments的一小部分。尽管如此,通过查看 `assay` 槽中的
计数我们仍然可以研究 *SummarizedExperiment* 的结果。样本的表型数据在 `colData` 槽中
（在本例中是一个空的 *DataFrame*），有关基因的数据在`rowRanges` 槽中。

```{r}
se
dim(se)
assayNames(se)
head(assay(se), 3)
colSums(assay(se))
```

`rowRanges`在打印时,只展示第一个*GRanges*，并告诉我们还有19个元素：

```{r}
rowRanges(se)
```

`rowRanges`也包含与 `metadata` 槽中的基因模型的构建有关的元数据。
这里我们使用`str`这个R函数来简洁的展示mmetadata。

```{r}
str(metadata(rowRanges(se)))
```

The `colData`:

```{r}
colData(se)
```

`colData`插槽目前还是空的，而它应该包含所有的元数据。因为我们使用`sampleTable`
这一列来生成`bamfiles`矢量，所以我们知道`se`列的顺序和`sampleTable`行的顺序是
一样的。我们可以把`sampleTable`分配为总结性实验的`colData`，这要通过把它转换成
一个*DataFrame*并使用分配函数来实现。

```{r}
colData(se) <- DataFrame(sampleTable)
colData(se)
```

## 分支点

现在，我们已经根据指定的基因模型算出了重叠在基因上的fragments，这是一个分支点，此处我们
可以使用众多的Bioconductor包对算得的数据进行探索和差异表达分析。包括
`r Biocpkg("edgeR")` [@Robinson2009EdgeR],
`r Biocpkg("limma")` with the voom method [@Law2014Voom],
`r Biocpkg("DSS")` [@Wu2013New],
`r Biocpkg("EBSeq")` [@Leng2013EBSeq] and
`r Biocpkg("baySeq")` [@Hardcastle2010BaySeq].
@Schurch2016How
[compared performance](https://www.ncbi.nlm.nih.gov/pmc/articles/pmid/27022035/) 
各种不同的统计学方法为RNA-seq进行了大量的生物学重复，这有助于用户决定使用哪些工具是最合适的，
以及达到某一程度的灵敏度需要多少生物学重复。
我们会继续使用`r Biocpkg("DESeq2")` [@Love2014Moderated]。我们都需要
*SummarizedExperiment*对象来开始我们的分析。下面的部分我们会展示如何用它来
建立供`r Biocpkg("DESeq2")`使用的数据对象。

<a id="construct"></a>

# *DESeqDataSet*对象，样本信息和设计公式

Bioconductor软件包通常定义和使用自定义的类来存储数据，以确保始终提供所有需要的数据槽并满足
分析需求。此外，Bioconductor有一般性的数据类（如 *SummarizedExperiment* ）可用于在包之间转移
数据。此外，Bionconductor的核心类提供了一些有用的功能函数：例如，对一个 *SummarizedExperiment*
 的行或列取子集或者重排序，会自动对关联的 *rowRanges*和colData* 也取子集或重排序，这有助于
防止意外的样本交换，这种交换会导致结果的虚假性。这些都已经在 *SummarizedExperiment* 的内部做好了。

在 *DESeq2* 中，自定义的类叫做 *DESeqDataSet* 。它建立在*SummarizedExperiment*类的顶部，
所以很容易将 *SummarizedExperiment* 对象转变成 *DESeqDataSet* 对象，如下所示。第一个主要的区别是 `assay` 插槽被替之以 *counts* 存取器函数访问，并且 *DESeqDataSet* 类
强制要求矩阵中的值为非负整数。

第二个主要区别是 *DESeqDataSet* 有关联的 *设计公式* 。实验设计在分析开始的时候被指定，
这个公式会通知许多的 *DESeq2* 函数如何处理所分析的样本（尺寸因子估算，即不同文库的尺寸校正，是例外的，
它不依赖于设计公式）。设计公式能分辨出样本信息表中的哪些列指定了实验设计以及这些因子如何应用
于分析。

用于差异表达分析的最简单的设计公式是`~ condition`，`condition`是 `colData(dds)`
 中的一列，该列指定这两个样本（或者更多的组）属于哪一个condition。对于这个呼吸道实验，我们会指定
 `~ cell + dex` ，意思是我们想测试地塞米松（`dex`）在不同的细胞系中的影响效果。我们可以在
 *SummarizedExperiment* 或者 *DESeqDataSet* 中用 `$` 来查看每一列。

```{r secell}
se$cell
se$dex
```

**注意：** 在R中，将因子的第一个水平设为参考水平更加合适。（比如，对照的或者未处理的样本），所以
我们可以像这样 *relevel* `dex` 因子：

```{r sedex}
library("magrittr")
se$dex %<>% relevel("untrt")
se$dex
```

`%<>%` 是 `r CRANpkg("magrittr")` 包中的复合赋值管道运算符，上面的这行代码是下方代码的简洁写法。

```{r explaincmpass, eval = FALSE}
se$dex <- relevel(se$dex, "untrt")
```

为了运行*DESeq2*模型，你可以使用R的公式表示法来表达任何的固定效应的实验设计。
注意*DESeq2*使用相同公示表示法，像例如，R基本函数*lm*那样。如果研究目标是发现整个组
中的哪个基因的影响或者处理是不同的，那么交互性条款就能用一个像
`~ group + treatment + group:treatment`这样的设计来纳入并检验。更多例子请查看手册的`?results`
页面。我们会在下面的一个时间进程的示例中展示如何用一个交互性条款来检验特定条件的改变。

接下来的部分我们会从两个出发点来展示 *DESeqDataSet* 的构建：

* 从一个 *SummarizedExperiment* 对象开始
* 从一个技术矩阵和一个样本信息表开始

有关用Python包 *HTSeq* 来计数read的完整示例，请查看`r Biocexptpkg("pasilla")`
的指南。有关用 *htseq-count* 产出的文件来生成 *DESeqDataSet* 示例请查看
 `r Biocpkg("DESeq2")` 的简介。

## 从*SummarizedExperiment*开始

现在我们用R的 *data* 命令来加载一个准备好的 *SummarizedExperiment*，它来自与@Himes2014RNASeq
有关的公开可取的序列数据文件，我们在前面已经描述过了。我们用于生成此对象的步骤与您在前面部分中完成的步骤相同，但是这里我们用的是全部的reads和全部的基因。关于此步骤的更多细节，在您的R程序中键入
`vignette("airway")`。

```{r}
data("airway")
se <- airway
```

再一次的，我们指定：`untrt` 是dex变量的参考水平：

```{r}
se$dex %<>% relevel("untrt")
se$dex
```

我们可以快速检查上百万的与基因唯一比对的fragments。（第二个参数 *round* 告诉我们保留
多少小数点）。

```{r}
round( colSums(assay(se)) / 1e6, 1 )
```

假设我们已经用前面部分所描述的方法之一构建了一个 *SummarizedExperiment*，现在要确认此对象
中是否包含了关于样本的所有必要信息，即一个存储在`colData`槽中的表格，该表格中元数据
在计数矩阵的列上面。

```{r}
colData(se)
```

这里可以看出这个对象已经包含了一个信息全面的`colData` 槽——因为我们早已为您准备好了，
像`r Biocexptpkg("airway")` 的指南中描述的那样。
但是，当您使用自己的数据时，您必须这个步骤中添加自己实验的相关样本/表型信息。我们强烈建议
将这个信息放在一个逗号分隔符文件（CSV）或者制表符分隔符文件（TSV）中以便Excel处理，同时
将这个表格导入 `colData` 槽中，并确保它的行与 *SummarizedExperiment* 的列是对
应的。我们之前通过使用样本表格的列指定BAM文件来确保此对应关系。

一旦我们有了完整的注释好的 *SummarizedExperiment* 对象，我们可以构建借此构建一个
 *DESeqDataSet* 对象，其将构成分析的起点。
 我们给分析加入一个恰当的设计：

```{r}
library("DESeq2")
```

```{r}
dds <- DESeqDataSet(se, design = ~ cell + dex)
```

## 从计数矩阵开始

这个部分，我们会展示在只有一个计数矩阵和一个样本信息表格的情况下，如何建立一个
 *DESeqDataSet* 。

**注意：** 如果你已经准备好了一个 *SummarizedExperiment* ，那么你应该跳过此部分。
之前的部分用来从 *SummarizedExperiment* 中构建一个 *DESeqDataSet*，这里我们首先
从 *SummarizedExperiment* 中提取出单个的对象（计数矩阵和样本信息），从而回退建立一个
新的对象——仅仅是为了演示而已。
实际上，计数矩阵不是从一个文件从读取，就是从类似 *featureCounts* 这样的
`r Biocpkg("Rsubread")` package [@Liao2014FeatureCounts]中的R函数生成的。

 *SummarizedExperiment* 中的信息可以通过存取器函数来存取。例如，查看实际数据，在这里
 即为the fragment counts，可以使用 *assay* 函数。（ *head* 函数作用是将输出结果
 限制为开头的几行。）

```{r}
countdata <- assay(se)
head(countdata, 3)
```

在这个计数矩阵中，每一行代表一个Ensembl基因，每一列代表一个测序的RNA文库，并且这些值给出
了在每个文库中唯一分配给相应基因的片段的原始数量。我们也有每个样本的信息（计数矩阵的列）。
如果您用其他的软件算过reads，非常重要的一点就是计数矩阵的列要和样本信息表格的行相对应。

```{r}
coldata <- colData(se)
```

现在我们已经有了用来准备数据对象的所有的要素，并且这些要素呈现为一种适合分析的格式，它们是：

* `countdata`: 一个计数片段的表格
* `coldata`: 一个样本信息的表格

为了用计数矩阵和样本信息表格构建 *DESeqDataSet* 对象，我们使用：

```{r}
ddsMat <- DESeqDataSetFromMatrix(countData = countdata,
                                  colData = coldata,
                                  design = ~ cell + dex)
```

我们会用用 *SummarizedExperiment* 部分生成的对象继续下面的部分。

<a id="eda"></a>

# 探索性分析和可视化

本工作流程走向两个不同的路径：我们首先看到的将是 *计数值的转换*，
这部分是为了可视化的探索样本之间的关系。第二个路径我们会回退到原始的计数值进行
 *统计检验*。统计检验的方法依赖于原始的计数值数据（未经缩放或
 转换）来计算测量方法的精确度。

## 数据集预过滤

我们的 *DESeqDataSet* 的技术矩阵中的许多行都是0，此外许多行只有很少的fragments
数目。为了减少对象的尺寸，也为了加速函数运行，我们可以移除这些行。这里我们使用了最小化
的过滤规则：移除 *DESeqDataSet* 中0数目的行，或者对所有的样本只有单次计数的行。额外
的加权/过滤以提高效能会在后面的步骤中应用到。

```{r}
nrow(dds)
dds <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds)
```

## 方差稳定转换和rlog

用于多维数据的探索性分析的许多常用统计方法，例如聚类和
 *主成分分析* （PCA），在均值范围不同而方差的范围相同的数据上效果最好。当均值不等而预期的
 方差数目大致相等时，这种数据叫做 *homoskedastic* 。
但是对于RNA-seq counts，期望的方差总是随平均值变化而变化。例如，如果直接在原始的或标准化
（比如对测序深度的差异进行了校正）的计数矩阵上进行PCA，得出的结果图通常会受到有 *highest*  
计数的基因的很大影响，因为它们展示出了样本间最大绝对差异。要避免这种情况，一种简单且实用的
方法是在标准化计数的对数上加上伪数值1；然而，根据选择的伪数值的不同，有 *lowest* 计数的基
因会在结果图上造成大量的噪声，因为小的计数值的对数实际上扩大了方差。我们可以快速地用一些模拟
数据来展示计数值的这种特性。（这里，泊松计数值有一个从0.1到100的lambda范围）。我们画出了每
一行（基因）均值的标准差：

```{r meanSdCts}
lambda <- 10^seq(from = -1, to = 2, length = 1000)
cts <- matrix(rpois(1000*100, lambda), ncol = 100)
library("vsn")
meanSdPlot(cts, ranks = FALSE)
```

对于log转换的计数:

```{r meanSdLogCts}
log.cts.one <- log2(cts + 1)
meanSdPlot(log.cts.one, ranks = FALSE)
```

当值近似于0时，一个小的伪数值的对数会使差异增大。具有低信噪比的低计数基因将过度影响
样品 - 样品距离和PCA图。

为了解决这个问题， *DESeq2* 为计数数据提供了两个转换方法来稳定平均值的方差：
 *方差稳定转换* (VST)，用于有离均趋势的负二项数据@Anders2010Differential]，
 用 *vst* 函数执行，以及 *正规化log转换* 或者  *rlog* [@Love2014Moderated]。

对于高计数的基因，VST和rlog对一般的均一化计数值的log2转换有相似作用。然而，对于
低计数值的基因，转换后的值会趋向于中间值。之后VST或者rlog转换的数据会变成近似的同方差
（在 *meanSdPlot* 中趋势更平缓），可以直接用来计算样本间的距离，画PCA图，或者作为下
游的会用到同方差数据的方法的输入。


**选择哪一个转换方法？** 
VST的计算速度要快得多，并且对高计数异常值的敏感度低于rlog。rlog在小数据集（n < 30）
上工作得更好，当存在跨样本的大范围的测序深度时，VST可能表现得更好（一个数量级的差异）。
因此我们推荐在中到大的数据集（n > 30）上使用VST。你也可以两个转换方法都用，比较
生成的 `meanSdPlot` 或PCA图，就像下面描述的那样。

注意，DESeq2提供的两个转换方法是为差异测试以外的应用 *other* 提供的。
对于差异测试，我们推荐使用适用于原始计数值的 *DESeq* 函数，像本工作流程后面描述的那样，
该函数也考虑到了在离差估算步骤中计数值的方差对于平均值的依赖。

*vst* 和 *rlog* 都会返回一个基于 *SummarizedExperiment* 类的 *DESeqTransform* 
对象。转换后的值不再是计数值，并存储在 *assay* 槽中。附加在 `dds` 的 *colData* 仍然
是可以访问的。

```{r vst}
vsd <- vst(dds, blind = FALSE)
head(assay(vsd), 3)
colData(vsd)
```

同样的, 对于 *rlog*：

```{r rlog}
rld <- rlog(dds, blind = FALSE)
head(assay(rld), 3)
```

在上面的函数调用中，我们设置了 `blind = FALSE` ，意思是着细胞系和处理之间的差异
（实验设计中的变量）将不会影响预期的方差-均值实验的趋势。实验设计不直接用于转换，仅用
于估计计数中的全局变异量。对于完全的 *无监督* 转换，可以设置 `blind = TRUE` 
（这是默认设置）。

为了展示转换的效果，下图中我们绘制了第一个和第二个样本，第一个简单地使用了 *log2* 函数
（在加了1之后，以避免产生og0），接着使用了VST和 rlog转换后的值。
对于 *log2* 途径，我们首先需要估算 *尺寸因子* 来来解释测序深度，然后指定
`normalized=TRUE` 。
测序深度校正在 *vst* 和 *rlog*中是自动完成的。

```{r transformplot, fig.width = 6, fig.height = 2.5}
library("dplyr")
library("ggplot2")

dds <- estimateSizeFactors(dds)

df <- bind_rows(
  as_data_frame(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_data_frame(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  

ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation)  
```

**两个样本的转换后的计数的散点图**. 这里展示的是分别用的log2转换（左边），VST（中间），
以及rlog（右边）画出来的标准化计数值的散点图。可以看到，rlog与log2的计数值大致上是相同
尺度的，对于较小的值，VST会上移一点。 样本之间的差异（散点图上相对于y=x的偏差）有助于
样本距离计算和PCA绘图。

我们可以看见低计数值的基因（左下角）似乎在正常的对数尺度上变化很大，对于那些在差异表达
上提供了很少信息的数据，VST和rlog压缩了低计数值基因之间的差异。

## 样本距离

RNA-seq分析一个有效的第一步通常是评估样本之间的整体相似性：哪些样本彼此相似，哪些是不
相似的？这些符合实验设计的预期吗？

我们用R函数 *dist* 来计算样本之间的欧几里得距离。我们在VST数据上使用这个函数以确保所有
的基因有大致相等的影响。我们需要用 *t* 来调换矩阵的值，因为 *dist* 函数期望它的
参数的行是不同的样本，列是不同的维度（在这里是基因）。

```{r}
sampleDists <- dist(t(assay(vsd)))
sampleDists
```

使用 `r CRANpkg("pheatmap")` 包中的 *pheatmap* 函数，我们在下面的一张图中用热图可视化地
展示了样本距离。

```{r}
library("pheatmap")
library("RColorBrewer")
```

为了绘制行或列按照距离排列的样本距离矩阵，我们手动地给 *pheatmap* 函数的
 `clustering_distance` 参数提供 `sampleDists` 。
否则 *pheatmap* 会假设矩阵包含数据值本身，并且会计算距离矩阵行/列之间的距离，这不是
我们所期望的。
我们也会手动的用 `r CRANpkg("RColorBrewer")` 包中的 *colorRampPalette* 函数来
指定一个蓝色的调色板。

```{r distheatmap, fig.width = 6.1, fig.height = 4.5}
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( vsd$dex, vsd$cell, sep = " - " )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors)
```

**使用了rlog转换值的样本间距离热图**

注意我们已经改变了距离矩阵中的行名，现在的行名是处理类型-病人的编号，
这样我们就能在看热图时看到所有的这些信息。

另一个计算样本距离的选择是使用 *泊松距离* [@Witten2011Classification]，
由 `r CRANpkg("PoiClaClu")` 包来执行。
在计算样本距离时，这种计数值之间的不相同的度量也考虑了计数值的内部方差结构。 
*PoissonDistance* 函数将样本的原始计数矩阵（未均一化）作为行而不是列，所以我们
需要用 `dds` 调换计数值。

```{r}
library("PoiClaClu")
poisd <- PoissonDistance(t(counts(dds)))
```

我们在下图中画了一个热图。

```{r poisdistheatmap, fig.width = 6.1, fig.height = 4.5}
samplePoisDistMatrix <- as.matrix( poisd$dd )
rownames(samplePoisDistMatrix) <- paste( dds$dex, dds$cell, sep=" - " )
colnames(samplePoisDistMatrix) <- NULL
pheatmap(samplePoisDistMatrix,
         clustering_distance_rows = poisd$dd,
         clustering_distance_cols = poisd$dd,
         col = colors)
```

**使用了 *Poisson Distance* 距离的样本间记录的热图。**

## PCA图

另一种可视化样本到样本距离的方式是主成分分析（PCA）。在这种方法中，数据点(这里指样本）
映射到2D平面，他们分散在两个方向上，这能解释大多数的差异（下图所示）。X轴是数据点最多
的方向。这个方向的样本的值记为 *PC1* 。y轴是数据点第二多方向（必须和第一个方向呈
*直角* ）。这个方向的样本的值记为 *PC2* 。
方向的总体方差的百分数写在坐标轴标签中。注意这个百分比并没有加到100%，因为还有更多的维度中
包含有剩下的差异。（然而这些维度的差异占比非常小）。

```{r plotpca, fig.width=6, fig.height=4.5}
plotPCA(vsd, intgroup = c("dex", "cell"))
```

**使用了VST数据的PCA图。** 不同处理和细胞系的组合有不同的颜色

我们在这使用了 *DESeq2* 的 *plotPCA* 函数。由 `intgroup` 指定的两个参数是我们想区分样本的
两个组别。它们告诉函数根据它们来选择颜色。我们也能用
 `r CRANpkg("ggplot2")`[@Wickham2009Ggplot2] 包从草稿中建立PCA图。
这是通过让 *plotPCA* 函数返回用于画图的数据而不是直接作图来实现的。
关于 *ggplot* 函数的更多细节请参考 *ggplot2* [documentation](http://docs.ggplot2.org/current/)。

```{r}
pcaData <- plotPCA(vsd, intgroup = c( "dex", "cell"), returnData = TRUE)
pcaData
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

之后我们可以用这些数据来建立第二张图，如下图所示，图中点的颜色对应地塞米松处理，点的形状对应
细胞系。

```{r ggplotpca, fig.width=6, fig.height=4.5}
ggplot(pcaData, aes(x = PC1, y = PC2, color = dex, shape = cell)) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed()
```

**用自定义的  *ggplot2* 代码画的VST值的PCA图**
这里我们指定了细胞系（作图符号）和地塞米松处理（颜色）。

从PCA图中，我们看出不同细胞之间的差异是相当大的（不同的形状），但是地塞米松治疗的
差异更大（红色 VS 蓝色）。这展示了为什么在不同的检验要用这种成对的设计来解释这个
的重要性（“paired”，即在 *same* 细胞系中每个地塞米松治疗样本都有一个对应的
未治疗的样本）。之前我们已经通过配置公式 `~ cell + dex` 来建立了这种设计。

## MDS图

另一个和PCA图很相似的图，用基于R的 *多维标度法* (MDS) 函数来制作。
当我们没有并数据矩阵，只有距离矩阵时，这个图会很有用。这里我们分析了用 *VST* 数据
计算出的距离上的MDS，并画成了下图。

```{r mdsrlog, fig.width=6, fig.height=4.5}
mds <- as.data.frame(colData(vsd))  %>%
         cbind(cmdscale(sampleDistMatrix))
ggplot(mds, aes(x = `1`, y = `2`, color = dex, shape = cell)) +
  geom_point(size = 3) + coord_fixed()
```

**用VST数据画的MDS图。**

在下面的这张图中我们展示了用 *PoissonDistance* 画的同样的图。

```{r mdspois, fig.width=6, fig.height=4.5}
mdsPois <- as.data.frame(colData(dds)) %>%
   cbind(cmdscale(samplePoisDistMatrix))
ggplot(mdsPois, aes(x = `1`, y = `2`, color = dex, shape = cell)) +
  geom_point(size = 3) + coord_fixed()
```

**用 *PoissonDistance* 画的MDS图**

<a id="de"></a>

# 差异表达分析

## 启动差异表达分析的流程

因为我们早在创建 *DESeqDataSet* 时就指定了实验设计，所以现在简单的调用 *DESeq* 函数就可以
运行差异表达分析的流程：

```{r airwayDE}
dds <- DESeq(dds)
```

这个函数会打印出它执行的各个步骤的信息。更多细节可以查看手册上有关 *DESeq* 的页面，
您可以通过 `?DESeq` 来访问。主要是：这些步骤尺寸因子的估算（样本测序深度的差异控制），
每个基因的离散值的估算，以及拟合广义线性模型。

一个 *DESeqDataSet* 会被返回，其中包含所有的拟合参数，下面的部分描述了如何从该对象
中提取出感兴趣的结果表格。

## 建立结果表格

不带参数的调用 *results* 会生成设计规范中的最后一个变量的估计的log2倍数变化值
以及 *p* 值。如果这个变量有超过2个水平，那么 *results* 函数会生成一个结果表格以比较
后一个水平和前一个水平，其会在输出的顶部打印出来：`dex trt vs untrt` 。

```{r}
res <- results(dds)
res
```

我们可以使用以下更具体的命令等效地生成此结果表。由于 `dex` 是设计的最后一个变量，我们可以
选择省略 `contrast` 来生成 `dex` 的两个水平的比较。

```{r}
res <- results(dds, contrast=c("dex","trt","untrt"))
```

因为 `res` 是一个 *DataFrame* 对象，所以它的列名的含义就是它的元数据。

```{r}
mcols(res, use.names = TRUE)
```

第一列， `baseMean` 是归一化的计数值的平均值, 由尺寸因子划分开，取自 *DESeqDataSet*
的所有样本。
其他四列指特定的对比，即因子变量 `dex` 的 `trt` 水平与 `untrt` 的对比。下面我们会
阐明如何获得其他的对比。

`log2FoldChange` 列是效应大小估计。它是指地塞米松治疗样本与不治疗样本对比，有多少基因
表达改变了。这个值是一个以2为底的log值：例如，log2倍数变化为1.5的意思是基因
表达增加了 \(2^{1.5} \approx 2.82\)倍。

当然，这个估计值有不确定性，这个不确定性在 `lfcSE` 列中表示，该列是log2倍数变化
的标准差估计。作为统计检验的结果，我们还可以表示特定效应大小估计的不确定性。对差异表达进行
检验的目的是确定数据是否有足够的证据证明值与0有差异。*DESeq2* 为每个基因执行*假设检验*
以确定是否有足够证据来推翻*无效假设*，这个无效假设是指治疗对基因是没有影响的，现在观察
到的治疗组与对照组之间的差异只是实验的随机误差造成的。（即在同一个治疗组里你可以预期的不同样本间的
变异性的类型）。通常在统计中，这种检验的结果是用 *p* 值来表示的，即实验组与对照组的倍数变化没有差别
甚至对照组更强的可能性，将在无效假设描述的情况下看到。

我们还可以使用以下代码行汇总结果，这些代码会报告一些其他信息，这些信息将在后面的章节中介绍。

```{r}
summary(res)
```

注意在FDR水平为10%的情况下，地塞米松处理组的许多基因出现差异表达。这是说得通的，因为已知呼吸道
的平滑肌细胞会与糖皮质激素起反应。然而，有两种方法更严格的确定哪些基因是更加有意义的：

* 降低错误发现率的阈值 (有关 `padj` 的临界值)
* 用 *results* 的 `lfcThreshold` 参数来从0提高log2倍数变化的阈值

如果我们降低错误发现率的阈值，我们也要将其报给 `results()` 函数，这样该函数就能用这个阈值来
进行最佳的独立性过滤：

```{r}
res.05 <- results(dds, alpha = 0.05)
table(res.05$padj < 0.05)
```

如果我们想提高log2倍数变化的阈值，以检验出那些在处理中变化较大的基因，我们可以简单的给
log2 尺度添加一个值。例如，通过指定 `lfcThreshold = 1` ，我们会检验出那些在治疗中差异表达
增加2倍以上或者降低到一半以下的基因，因为 \(2^1 = 2\)。

```{r}
resLFC1 <- results(dds, lfcThreshold=1)
table(resLFC1$padj < 0.1)
```

有时候 `res` 中的 *p* 值的会有一个子集是 `NA` （没有得到）。这是 *DESeq* 中报告这个基因的所有
计数值都是0的方式，因此不会应用任何检验。 此外，如果基因由于包含一个极端的异常值而被剔除出分
析，那么 *p* 值也会是 `NA` 。更多信息请参考 *DESeq2* 简介中有关异常值检测的部分。

如果你将R包分析的结果用在公开的研究中，你可以通过键入`citation("pkgName")` 来找到
这个包的特定引用格式，你要用包的名字来替换 `pkgName`。在你的paper中注明对这些包的引用
会极大的鼓励那些开发这些开源的基因组数据分析软件的人，毕竟他们在这些软件上花费了大量的时间。

## 其他比较

总之，一个变量的任何两个水平之间的比较结果可以用 *results* 的 `contrast` 参数提取到。
用户要指定3个值：变量的名字，分子上的水平的名字以及分母上的水平的名字。这里我们提取了两个
细胞系之间的log2倍数变化的结果：

```{r}
results(dds, contrast = c("cell", "N061011", "N61311"))
```

在运行了 *DESeq* 一次后，还有一些其他的方法来为某些比较建立结果表格。
如果需要交互项的结果，那么要使用 *results* 的 `name` 参数。请参考 *results* 
函数的帮主页面以获取更多有关用其他方式来建立结果表格的详细信息。尤其是 *results* 
帮主页面的 **Examples** 部分给出了几个很有用的例子。

## 多重检验

在高通量生物学中，我们不要急着直接用 *p* 值来否定无效假设，而要用 *多重检验*
来进行校正。如果我们简单地将 *p* 值的临界值设定为一个比较低的值会怎样，比如0.05？
在检验中成功报告了一个 *p* 值的 `r sum(!is.na(res$pvalue))` 基因中会存在 *p* 
值低于0.05的`r sum(res$pvalue < .05, na.rm=TRUE)` 基因： 

```{r sumres}
sum(res$pvalue < 0.05, na.rm=TRUE)
sum(!is.na(res$pvalue))
```

现在，假设对所有基因来说，无效假设都是对的，即没有基因受到了地塞米松处理的影响。
那么，基于 *p* 值的定义，我们期望超过5%的基因的 *p* 值低于0.05。这总计为
`r round(sum(!is.na(res$pvalue)) * .05 )` 个基因。
如果我们仅仅认为 *p* 值低于0.05的基因的列表是差异表达的，那么该列表应该包含多达
`r round(sum(!is.na(res$pvalue)) * .05)` /
`r sum(res$pvalue < .05, na.rm=TRUE)` =
`r round(sum(!is.na(res$pvalue))*.05 / sum(res$pvalue < .05, na.rm=TRUE) * 100)`%
 假阳性。

*DESeq2* 使用基础R函数中实现Benjamini-Hochberg (BH) 调整
[@Benjamini1995Controlling]。简单来说就是，这个方法为每个基因计算一个调整过的 *p* 
值，该值回答了以下问题：如果一个经检验为显著的基因，它的调整后 *p* 值小于等于这个基因
的调整后 *p* 值的阈值，那么在此意义上，所有的显著性基因假阳性率（ *错误发现率*, FDR）
是多少？这个值被叫做BH调整 *p* 值，在 `res` 列的 `padj` 列中给出。

FDR在很多的高通量实验的统计中都很有用，因为我们经常乐于聚焦在一组有趣的基因上，
因此我们想要给这组的假阳性百分比设置一个上限。

因此，如果我们考虑10%的假阳性率是可以接受的，那么我们认为所有的调整后的 *p* 小于0.1
的基因都是显著的。这样的基因有多少呢？

```{r}
sum(res$padj < 0.1, na.rm=TRUE)
```

我们对结果表格中的这些基因取子集，然后按照log2倍数变化值进行排序，从而获得下调得最多
的显著基因：

```{r}
resSig <- subset(res, padj < 0.1)
head(resSig[ order(resSig$log2FoldChange), ])
```

...以及上调最多的基因:

```{r}
head(resSig[ order(resSig$log2FoldChange, decreasing = TRUE), ])
```

<a id="plots"></a>

# 结果绘图

## 计数值绘图

要可视化地展示一个特定基因的计数值，最快的方法是用 *plotCounts* 函数，该函数将
*DESeqDataSet* ，基因的名字，以及用于画图的组作为参数（下图）。

```{r plotcounts}
topGene <- rownames(res)[which.min(res$padj)]
plotCounts(dds, gene = topGene, intgroup=c("dex"))
```

**基于处理组的单个基因的标准化计数值。**

我们也可以用 `r CRANpkg("ggplot2")` 包的 *ggplot* 函数来定制图（下图）。

```{r ggplotcountsjitter, fig.width = 4, fig.height = 3}
library("ggbeeswarm")
geneCounts <- plotCounts(dds, gene = topGene, intgroup = c("dex","cell"),
                         returnData = TRUE)
ggplot(geneCounts, aes(x = dex, y = count, color = cell)) +
  scale_y_log10() +  geom_beeswarm(cex = 3)
```

```{r ggplotcountsgroup, fig.width = 4, fig.height = 3}
ggplot(geneCounts, aes(x = dex, y = count, color = cell, group = cell)) +
  scale_y_log10() + geom_point(size = 3) + geom_line()
```

**将细胞系用线连起来的标准化计数值.**
注意到 *DESeq* 检验实际上考虑到了细胞系的影响，所以这个图更准确的描绘了检验的差异。

## MA图

 *MA-plot* 展示了一个针对模型评估系数分布情况的概览，例如，在全部基因的尺度上对我们感兴趣的
 变量进行比较， 在Y轴上，"M"代表"minus"--
subtraction of log values is equivalent to the log of the ratio --
在X轴上，"A"代表"average"，此图也称为为均值差异图或者Bland-Altman图。

在绘制MA-plot之前，我们使用 *lfcShrink* 函数来缩减地塞米松治疗样本和未治疗样本之间的
log2倍数差异。 *DESeq2* 中有3种类型的缩减器，详见[DESeq2 vignette](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)。
这里我们制定 *apeglm* 方法来缩减系数，其善于缩减嘈杂的LFC估计值，同时为非常大的差异给出
低偏差的LFC估计值[@Zhu2018]。要使用 *apeglm* ，我们可以通过名字或序号来指定一个模型
中的收缩系数，因为系数出现在 `resultsNames(dds)` 中。

```{r plotma}
library("apeglm")
resultsNames(dds)
res <- lfcShrink(dds, coef="dex_trt_vs_untrt", type="apeglm")
plotMA(res, ylim = c(-5, 5))
```

如果要指定 `resultsNames(dds)` 中没有的对比度，可以使用其他的两种收缩方法的任一种，
或者在某些情况下，重构相关的变量，然后运行 `nbinomWaldTest` 再运行 `lfcShrink` 
就可以了。更多细节请参考DESeq2简介。

**An MA-plot of changes induced by treatment.**
特定比较间的log2倍数变化绘制在Y轴，经尺寸系数标准化的计数值的均值展现在X轴。
每个点代表一个基因。调整后的 *p* 值小于临界值（这里是0.1，默认的）的基因，显示
为红色。


 *DESeq2* 包使用贝叶斯程序来缓和（或缩减）极低计数值且计数值差异巨大的基因的
 log2倍数变化，通过缩小MA-plot左侧点的垂直扩展可以看出。如上所示， *lfcShrink* 
 函数执行这个操作。
 关于缓和倍数变化的原理的更详细解释，请参见 *DESeq2* 页面[@Love2014Moderated]。

如果我们没有用统计调节来缩减嘈杂的log2倍数变化，我们可能会看到下图：

```{r plotmaNoShr}
res.noshr <- results(dds, name="dex_trt_vs_untrt")
plotMA(res.noshr, ylim = c(-5, 5))
```

我们也可以标记MA-plot上的各个点。这里我们使用了R函数 *with* 来给结果对象的选定行
绘制圈和文字。在 *with* 函数中， `res` 的选定行中只有 `baseMean` 和`log2FoldChange` 
值会被用到。

```{r plotmalabel}
plotMA(res, ylim = c(-5,5))
topGene <- rownames(res)[which.min(res$padj)]
with(res[topGene, ], {
  points(baseMean, log2FoldChange, col="dodgerblue", cex=2, lwd=2)
  text(baseMean, log2FoldChange, topGene, pos=2, col="dodgerblue")
})
```
另一个很有用的诊断图是 *p* 值的直方图（下图）。最好在此图中去掉极小计数值的基因，
否则会在直方图中产生峰值。

```{r histpvalue2}
hist(res$pvalue[res$baseMean > 1], breaks = 0:20/20,
     col = "grey50", border = "white")
```

**Histogram of *p* values for genes with mean normalized count larger than 1.**

## 基因聚类

在前面做的样本距离的热图中，边上的系统发育树展示了样本的分层聚类。这样的聚类也可以用在
基因上。由于聚类只与实际携带信号的基因有关，因此通常只聚类变化性最大的那些基因。这里，
作为展示，我们选取了跨样本的20个变化最大的基因。我们用VST数据来操作。

```{r}
library("genefilter")
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 20)
```

如果我们不考虑样本的绝对表达强度而是考虑相对所有样本中基因的平均值，每个基因在特定样本
中偏离的量，那么热图会变得更有趣。因此，我们将跨样本的每个基因集中，绘制热图（下图）。
我们提供 *data.frame* 来指导 *pheatmap* 函数如何给每一列打标签。

```{r genescluster}
mat  <- assay(vsd)[ topVarGenes, ]
mat  <- mat - rowMeans(mat)
anno <- as.data.frame(colData(vsd)[, c("cell","dex")])
pheatmap(mat, annotation_col = anno)
```

**Heatmap of relative VST-transformed values across samples.**
治疗状态和细胞系信息显示在热图顶部的彩色条。跨病人的基因块。注意热图顶部的一组
基因将N061011细胞系和其他细胞系分离开。在热图的中心，我们看到了一组用地塞米松
治疗的样本，她们有更高的基因表达。

##独立性检验

MA图突出了RNA-seq数据的一个重要属性。对于微弱表达的基因，我们很难观察其差异表达情况，
因为低reads计数值遭受了非常高的泊松噪声，以至于任何的生物效应都会在低采样率的
不确定性中被淹没。我们也可以通过检测经过平均归一化计数值打包的基因的小 *p* 值
（小于0.05）的比率来展示这个。我们将使用经受临界值的结果表格来展示在几乎没有小
 *p* 值检验的情况下这个看起来像什么。

在下面的代码块中，我们用 *quantile* 生成了一个容器，使用 *cut* 通过基本均值来
封装基因，用中点重命名容器的水平，计算每个容器 *p* 值小于0.05的比率，最后画出这
些比率（下图）。

```{r sensitivityovermean, fig.width=6}
qs <- c(0, quantile(resLFC1$baseMean[resLFC1$baseMean > 0], 0:6/6))
bins <- cut(resLFC1$baseMean, qs)
levels(bins) <- paste0("~", round(signif((qs[-1] + qs[-length(qs)])/2, 2)))
fractionSig <- tapply(resLFC1$pvalue, bins, function(p)
                          mean(p < .05, na.rm = TRUE))
barplot(fractionSig, xlab = "mean normalized count",
                     ylab = "fraction of small p values")
```

**The ratio of small *p* values for genes binned by mean normalized count.**
 *p* 值来源于一个log2倍数变化大于1或小于1的检验。这个图表明，平均计数非常低的基因没有或
 有很少的效能，最好从检验中排除。

咋一看，过滤这些基因似乎没有什么好处。毕竟，检验会会发现它们没有显著性。然而，这些基因会
对多重检验调整有影响，如果过滤这些基因，表现会提高。在FDR程序中的输入中移除的低计数值的
基因，我们能在我们保留的基因中发现更多的基因有显著性，从而能提高检验的效能。该途径用
*independent filtering* 实现。

 *DESeq2* 软件自动执行independent filtering，即最大化调整 *p* 值小于临界值的基因
（默认的 `alpha`是0.01）。这个自动的independent filtering是通过 *results* 
来执行和控制的。

*independent* 这个术语强调了一个重要的警告。只有当我们过滤的统计量（这里是所有样本的
归一化技术值的均值）不依赖于无效假设下的实际检验的统计量（ *p* 值），这种过滤才是被
允许的。否则，过滤会导致检验无效，最终导致BH过程的假设无效。
independent filtering软件使用 `r Biocpkg("genefilter")` 包中的 *DESeq2* ，
其中包含一个描述independent filtering的统计学基础的参考文献 [@Bourgon2010Independent]。

<a id="annotate"></a>

# 注释及结果导出

目前为止，我们的结果表格中只包含Ensembl基因的ID，但是替之以基因名能为解释提供更多的信息。
Bioconductor 的注释包用于不同的ID格式间的彼此映射。
We load the `r Biocpkg("AnnotationDbi")` package and the annotation package
`r Biocannopkg("org.Hs.eg.db")`:

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```
这个是用于 *Homo sapiens* ("Hs") 的生物体注释包，rganized as an *AnnotationDbi*
database package ("db"), using Entrez Gene IDs ("eg") as primary key.
要获得全部可获取的键的类型列表，使用：

```{r}
columns(org.Hs.eg.db)
```

我们可以使用 *mapIds* 函数来给我们的结果表格中添加个人的列。我们将结果表中的行名作为键，
并且指定 `keytype=ENSEMBL`。 `column` 参数告诉 *mapIds* 函数我们想要那个信息，并且
 `multiVals` 参数告诉函数如果单个的输入值有多个可能的值时应该怎么做。这里我们只要要求
返回给我们表格中的第一个。
为了添加 gene symbol和Entrez ID，我们调用 *mapIds* 两次。

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")
```

Now the results have the desired external gene IDs:

```{r}
resOrdered <- res[order(res$pvalue),]
head(resOrdered)
```

## 结果导出

您可以轻松地将结果表保存在CSV文件中，然后可以使用Excel等电子表格程序共享或加载该文件。
您需要调用 *as.data.frame* 函数来将 *DataFrame* 对象（`r Biocpkg("IRanges")` 包）
转换成能被 *write.csv* 函数处理的 *data.frame* 对象。这里，我们只用了100个基因来展示。

```{r eval=FALSE}
resOrderedDF <- as.data.frame(resOrdered)[1:100, ]
write.csv(resOrderedDF, file = "results.csv")
```
一个更完整的导出结果的方法是Bioconductor包 
`r Biocpkg("ReportingTools")` [@Huntley2013ReportingTools]。
*ReportingTools* 会自动地产生动态HTML文件，包括使用gene identifiers的外部数据库链接，
以及归纳了不同样本的归一化计数值的箱线图。更多细节请参看 *ReportingTools* 简介。最简单的
生成一个动态 *ReportingTools* 报告的版本是执行下面的代码：

```{r eval=FALSE}
library("ReportingTools")
htmlRep <- HTMLReport(shortName="report", title="My report",
                      reportDirectory="./report")
publish(resOrderedDF, htmlRep)
url <- finish(htmlRep)
browseURL(url)
```

##绘制基因组空间倍数变化图

如果我们 *summarizeOverlaps* 函数来计数reads，那么我们的 *DESeqDataSet* 对象建立
在指定了基因的基因组坐标的准备使用的Bioconductor对象上面。因而我们可以很容易的在基因组
尺度上画出差异表达结果。 *results* 函数默认返回一个 *DataFrame* ，使用 `format` 参数，
我们产生 *GRanges* 或 *GRangesList* 输出。*lfcShrink* 还没有输出  *GRanges* 的
选项，所以我们手动地添加收缩系数这一列。

```{r}
resGR <- results(dds, name="dex_trt_vs_untrt", format="GRanges")
resGR$log2FoldChange <- res$log2FoldChange
resGR
```

We need to add the symbol again for labeling the genes on the plot:

```{r}
resGR$symbol <- mapIds(org.Hs.eg.db, names(resGR), "SYMBOL", "ENSEMBL")
```

我们将使用 `r Biocpkg("Gviz")` 包来绘制GRanges和相关的metadata：由于地塞米松
治疗产生的log倍数变化。

```{r}
library("Gviz")
```

以下代码块指定了一个来自最小 *p* 值基因的上游和下游的100万碱基对的窗口。我们为这个
窗口的基因生成了一个完整结果的子集。如果符号存在并且在子集中没有重复，我们将基因
符号添加为名称。

```{r}
window <- resGR[topGene] + 1e6
strand(window) <- "*"
resGRsub <- resGR[resGR %over% window]
naOrDup <- is.na(resGRsub$symbol) | duplicated(resGRsub$symbol)
resGRsub$group <- ifelse(naOrDup, names(resGRsub), resGRsub$symbol)
```

We create a vector specifying if the genes in this subset had a low
value of `padj`.

```{r}
status <- factor(ifelse(resGRsub$padj < 0.1 & !is.na(resGRsub$padj),
                     "sig", "notsig"))
```

然后我们可以用 `r Biocpkg("Gviz")` 函数来绘制结果（下图）。我们生成了一个axis track
来指定我们在基因组中的坐标，track会显示基因及其名字，按照显著性来着色，同时一个data track
会画出vertical bars来显示用 *DESeq2* 生成的缓和的log倍数变化，这个data track只有在
计数信息很好的支持了效应的时候才会很大。

```{r gvizplot}
options(ucscChromosomeNames = FALSE)
g <- GenomeAxisTrack()
a <- AnnotationTrack(resGRsub, name = "gene ranges", feature = status)
d <- DataTrack(resGRsub, data = "log2FoldChange", baseline = 0,
               type = "h", name = "log2 fold change", strand = "+")
plotTracks(list(g, d, a), groupAnnotation = "group",
           notsig = "grey", sig = "hotpink")
```

**log2 fold changes in genomic region surrounding the gene with smallest
  adjusted *p* value.** Genes highlighted in pink have adjusted *p*
  value less than 0.1.

<a id="batch"></a>

# 移除批次效应

假如我们不知道实验中有不同的细胞系，只知道有有地塞米松的治疗。那么细胞系对计数的影响会
代表一些隐藏的和不需要的变异，这些变异或许正在影响许多或所有的在数据集中的基因。我们
可以使用 Bioconductor的 `r Biocpkg("sva")` 包或者 `r Biocpkg("RUVSeq")` 包
中用于RNA-seq的统计方法来检测这样的样本分组，之后我们可以把这些添加到 *DESeqDataSet* 
设计中以解释它们。

 *SVA* 包用术语 *surrogate variables* 来估算我们想在分析中解释的变量，而 *RUV*
包用术语 *factors of unwanted variation* 和 "Remove Unwanted Variation"
缩写来解释包的标题。我们首先用  *SVA* 来发现隐含的批次效应，之后用 *RUV*。

## 用DESeq2的SVA

```{r}
library("sva")
```

下面我们获得了一个归一化的计数的矩阵，其跨样本的平均计数大于1。正如我们上面所描述的那样，
我们正在试图揭开任何隐含的批次效应，在我们不知道细胞系信息的假设下。所以我们使用带有 *dex*
变量的完全模型矩阵，以及一个只带有截距项的简化的，或者空的模型矩阵。最终我们制定我们想要
估算两个代理变量。更多信息请键入 `?svaseq` 以查看手册上关于 *svaseq* 函数的页面。

```{r}
dat  <- counts(dds, normalized = TRUE)
idx  <- rowMeans(dat) > 1
dat  <- dat[idx, ]
mod  <- model.matrix(~ dex, colData(dds))
mod0 <- model.matrix(~   1, colData(dds))
svseq <- svaseq(dat, mod, mod0, n.sv = 2)
svseq$sv
```

因为实际上我们知道细胞系的信息，所以我们可以看见SVA方法在揭开这些变量上做的好不好（下图）。

```{r svaplot}
par(mfrow = c(2, 1), mar = c(3,5,3,1))
for (i in 1:2) {
  stripchart(svseq$sv[, i] ~ dds$cell, vertical = TRUE, main = paste0("SV", i))
  abline(h = 0)
 }
```

**Surrogate variables 1 and 2 plotted over cell line.**
这里，我们知道隐藏的变异资料（细胞系），因此我们能看见SVA程序是怎么鉴定出经细胞系校正的
变异资料的。

最终，为了使用SVA从我们的代理变量移除任何对计数的影响，我们简单地将这两个代理变量作为
 *DESeqDataSet* 中的列，并把它们添加到设计中去：

```{r}
ddssva <- dds
ddssva$SV1 <- svseq$sv[,1]
ddssva$SV2 <- svseq$sv[,2]
design(ddssva) <- ~ SV1 + SV2 + dex
```

之后我们可以在新设计下运行 *DESeq* 来产生代理变量控制的结果。

## 用DESeq2的RUV

我们也可以使用 *RUVSeq* 包中的 *RUV* 方法来检测隐含的批次效应。

```{r}
library("RUVSeq")
```

We can use the `RUVg` function to estimate *factors of unwanted
variation*, analogous to *SVA*'s *surrogate variables*.
与上面的 *SVA* 程序不同的一点是，我们首先要运行 *DESeq* 和 *results* 来获得
批次未知的分析的P值，例如，仅仅 `~ dex`。假设我们有这个结果表格 `res`，之后
通过考虑那些没有一个小P值的基因，我们可以拉出一系列 *empirical control genes* 。 

```{r}
set <- newSeqExpressionSet(counts(dds))
idx  <- rowSums(counts(set) > 5) >= 2
set  <- set[idx, ]
set <- betweenLaneNormalization(set, which="upper")
not.sig <- rownames(res)[which(res$pvalue > .1)]
empirical <- rownames(set)[ rownames(set) %in% not.sig ]
set <- RUVg(set, empirical, k=2)
pData(set)
```

We can plot the factors estimated by *RUV*:

```{r ruvplot}
par(mfrow = c(2, 1), mar = c(3,5,3,1))
for (i in 1:2) {
  stripchart(pData(set)[, i] ~ dds$cell, vertical = TRUE, main = paste0("W", i))
  abline(h = 0)
 }
```

**Factors of unwanted variation plotted over cell line.**

As before, if we wanted to control for these factors, we simply
add them to the *DESeqDataSet* and to the design:

```{r}
ddsruv <- dds
ddsruv$W1 <- set$W_1
ddsruv$W2 <- set$W_2
design(ddsruv) <- ~ W1 + W2 + dex
```

之后我们可以在新的设计下运行 *DESeq* 以重新评估参数和结果。

<a id="time"></a>

# 时间进程实验

*DESeq2* 可用于分析time course实验，例如找到那些与baseline样本比较，随着时间的推移
在特定条件下反应的基因。这里，我们演示了一个 `r Biocexptpkg("fission")` 数据包的
基础time course分析，其中包含裂殖酵母RNA-seq time course的基因计数[@Leong2014Global]。
这些酵母暴露于氧化应激，并且其中的一般含有 *atf21* 基因的缺失。
We use a design formula that models the strain difference at time 0,
the difference over time, and any strain-specific differences over
time (the interaction term `strain:minute`).


```{r}
library("fission")
data("fission")
ddsTC <- DESeqDataSet(fission, ~ strain + minute + strain:minute)
```

下面的代码块执行似然比检验，我们移除了随时间的指定压力差异。该检验中 *p* 值小的基因是那些
在time 0之后的一个或更多的时间点变现出了strain-specific效应的基因。注意，在两个strains
中以同一种方式随时间上下移动的基因不会被给予小的 *p* 值。

```{r fissionDE}
ddsTC <- DESeq(ddsTC, test="LRT", reduced = ~ strain + minute)
resTC <- results(ddsTC)
resTC$symbol <- mcols(ddsTC)$symbol
head(resTC[order(resTC$padj),], 4)
```

这个只是能够应用到time series数据的其中一个检验。另一个可选项是将计数建模为一个时间的光滑函数，
并且在光滑函数中包含一个条件的交互条款。可以使用R中的样条基函数来建立这个模型，更加现代的方法
使用Gaussian processes [@Tonner2016]。


We can plot the counts for the groups over time using
`r CRANpkg("ggplot2")`, for the gene with the smallest adjusted *p* value,
testing for condition-dependent time profile and accounting for
differences at time 0 (figure below). Keep in mind that the interaction terms are the
*difference* between the two groups at a given time after accounting for
the difference at time 0.

```{r fissioncounts, fig.width=6, fig.height=4.5}
fiss <- plotCounts(ddsTC, which.min(resTC$padj), 
                   intgroup = c("minute","strain"), returnData = TRUE)
ggplot(fiss,
  aes(x = as.numeric(minute), y = count, color = strain, group = strain)) + 
  geom_point() + geom_smooth(se = FALSE, method = "loess") + scale_y_log10()
```

**Normalized counts for a gene with condition-specific changes over time.**

可以使用 *results* 的 `test` 参数来调查单个时间点上的log2倍数变化的Wald检验：

```{r}
resultsNames(ddsTC)
res30 <- results(ddsTC, name="strainmut.minute30", test="Wald")
res30[which.min(resTC$padj),]
```

我们还可以通过基因的profiles来聚类基因。我们使用 *coef* 函数来提取出一个缩减的log2倍数变化
的矩阵：

```{r}
betas <- coef(ddsTC)
colnames(betas)
```

现在我们可以在热图中画出log2倍数变化（下图）。

```{r fissionheatmap}
topGenes <- head(order(resTC$padj),20)
mat <- betas[topGenes, -c(1,2)]
thr <- 3 
mat[mat < -thr] <- -thr
mat[mat > thr] <- thr
pheatmap(mat, breaks=seq(from=-thr, to=thr, length=101),
         cluster_col=FALSE)
```

**Heatmap of log2 fold changes for genes with smallest adjusted *p* value.**

底部的那组基因表现出15-60分钟内的对基准样本的强烈的诱导表达（左下角的红色框），但是对mutant 
strain有轻微的差异（展示在右下角的框里）。

<a id="ref"></a>

# 会话信息

作为此文档的最后一部分，我们调用 *sessionInfo* 函数，用来报告在此次会话中使用的R版本
和所有的包的版本。这是一个好习惯，因为当你的包更新了版本，其中的函数可能发生了变化，导致
R脚本停止工作或者给出了不同的结果，这个习惯就会对你有所帮助。将会话信息放在脚本的底部，
你的报告会具有更好的可复用性。

会话信息应该总是连同在分析中使用的代码一起，包含在发给
[Bioconductor support site](https://support.bioconductor.org)的邮件中。

```{r}
devtools::session_info()
```

# 参考文献

